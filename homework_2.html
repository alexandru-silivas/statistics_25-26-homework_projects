<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Homework 2 — Datasets, distributions and the Caesar Cipher</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

  <!-- top nav (must match style.css selectors) -->
  <header class="navbar">
    <nav>
      <ul class="nav-links">
        <li><a href="index.html">Home</a></li>
        <li><a href="homework_1.html">HMWK 1</a></li>
        <li><a href="homework_2.html" class="active">HMWK 2</a></li>
        <li><a href="homework_3.html">HMWK 3</a></li>
        <li><a href="homework_4.html">HMWK 4</a></li>
        <li><a href="homework_5.html">HMWK 5</a></li>
        <li><a href="homework_6.html">HMWK 6</a></li>
        <li><a href="homework_7.html">HMWK 7</a></li>
        <li><a href="homework_8.html">HMWK 8</a></li>
        <li><a href="homework_9.html">HMWK 9</a></li>
        <li><a href="homework_10.html">HMWK 10</a></li>
      </ul>
    </nav>
  </header>

   <main>
  <article class="main-content">
    <h1>Homework 2</h1>
    <h2>Dataset Distributions and the Caesar Cipher</h2>

    <p>
      This assignment explores the concept of statistical distributions through both univariate and bivariate analysis,
      integrating Microsoft Access SQL examples and a full treatment of letter-frequency analysis for cryptographic decoding.
      All queries and code blocks below are embedded exactly as provided in the original materials.
    </p>

    <!-- -------------------------
         SECTION 1: Dataset & Distribution
         ------------------------- -->
    <h3>1. Dataset and Distribution Concepts</h3>

    <p>
      A <strong>dataset</strong> is a structured collection of observations organized in rows (cases) and columns (variables).
      Each variable is a measured attribute (for example, <em>MathScore</em>, <em>StudyHours</em>, <em>SleepHours</em>).
      Datasets are the foundation of statistical analysis and allow us to summarize, visualize, and model phenomena.
    </p>

    <p>
      Variables are commonly classified by measurement scale:
    </p>
    <ul>
      <li><strong>Nominal</strong> — categories without order (e.g., department names).</li>
      <li><strong>Ordinal</strong> — ordered categories (e.g., grade levels).</li>
      <li><strong>Interval</strong> — numerical differences meaningful, no true zero (e.g., temperature °C).</li>
      <li><strong>Ratio</strong> — numerical values with absolute zero (e.g., hours studied).</li>
    </ul>

    <p>
      The <strong>distribution</strong> of a variable describes how its values are spread. Common shapes include:
    </p>
    <ul>
      <li><strong>Uniform</strong> — all outcomes equally likely.</li>
      <li><strong>Normal (Gaussian)</strong> — symmetric bell-shaped around the mean.</li>
      <li><strong>Skewed</strong> — long tail on one side (left or right skew).</li>
      <li><strong>Discrete vs Continuous</strong> — countable outcomes (discrete) vs measurable values (continuous).</li>
    </ul>

    <p>
      A <strong>univariate distribution</strong> analyzes a single variable, summarizing it with measures such as
      <em>mean, median, mode, variance, standard deviation</em>.
    </p>

    <p>
      On the other hand, a <strong>bivariate distribution</strong> analyzes two variables simultaneously
      (e.g., <em>MathScore</em> vs <em>StudyHours</em>) to study relationships like correlation.
    </p>

    <p>
      Visual tools for exploring distributions include histograms, density plots, boxplots (univariate) and scatterplots (bivariate).
      These help reveal central tendency, dispersion, skewness, and potential outliers.
    </p>

    <!-- -------------------------
         SECTION 2: Univariate Distributions in MS Access
         ------------------------- -->
    <h3>2. Univariate Distributions in Microsoft Access</h3>

    <p>
      Microsoft Access (Jet/ACE SQL) supports aggregate functions that compute descriptive statistics from tables.
      The following subsections show table creation, record insertion, and SQL queries that compute mean, standard deviation, min/max,
      and the final summary tables used in the assignment.
    </p>

    <h4>2.1 Creating the table (Students)</h4>

    <pre><code class="sql">
CREATE TABLE Students (
  ID AUTOINCREMENT PRIMARY KEY,
  Name TEXT(50),
  MathScore DOUBLE,
  StudyHours DOUBLE,
  SleepHours DOUBLE
);
    </code></pre>

    <h4>2.2 Inserting sample data</h4>

    <pre><code class="sql">
INSERT INTO Students (Name, MathScore, StudyHours, SleepHours) VALUES ('Alice',78,4.0,7.0);
INSERT INTO Students (Name, MathScore, StudyHours, SleepHours) VALUES ('Bruno',92,6.0,6.5);
INSERT INTO Students (Name, MathScore, StudyHours, SleepHours) VALUES ('Chiara',80,4.5,6.0);
INSERT INTO Students (Name, MathScore, StudyHours, SleepHours) VALUES ('David',88,5.0,6.8);
INSERT INTO Students (Name, MathScore, StudyHours, SleepHours) VALUES ('Emma',74,3.2,7.5);
    </code></pre>

    <h4>2.3 Compute mean and standard deviation (univariate summary)</h4>

    <p>
      The following query computes mean and standard deviation for each variable and returns them in a single result using <code>UNION ALL</code>:
    </p>

    <pre><code class="sql">
SELECT 'Math Score' AS Variable,
       Round(Avg([MathScore]), 1) AS Mean,
       Round(StDev([MathScore]), 1) AS StdDev
FROM Students
UNION ALL
SELECT 'Study Hours' AS Variable,
       Round(Avg([StudyHours]), 1) AS Mean,
       Round(StDev([StudyHours]), 1) AS StdDev
FROM Students
UNION ALL
SELECT 'Sleep Hours' AS Variable,
       Round(Avg([SleepHours]), 1) AS Mean,
       Round(StDev([SleepHours]), 1) AS StdDev
FROM Students;
    </code></pre>

    <p>
      Example result (as shown in the assignment):
    </p>

    <table style="width:100%; border-collapse:collapse; margin:1em 0; font-size:0.95rem;">
      <thead>
        <tr style="background:#111;">
          <th style="padding:8px; text-align:left;">Variable</th>
          <th style="padding:8px; text-align:left;">Mean</th>
          <th style="padding:8px; text-align:left;">Std Dev</th>
        </tr>
      </thead>
      <tbody>
        <tr><td style="padding:8px;">Math Score</td><td>82.4</td><td>8.6</td></tr>
        <tr><td style="padding:8px;">Study Hours</td><td>4.6</td><td>1.5</td></tr>
        <tr><td style="padding:8px;">Sleep Hours</td><td>6.7</td><td>0.9</td></tr>
      </tbody>
    </table>

    <h4>2.4 Min / Max / Average (single-query)</h4>

    <p>
      To get the minimum, maximum and average for a single variable (MathScore), run:
    </p>

    <pre><code class="sql">
SELECT Min([MathScore]) AS Minimum,
       Max([MathScore]) AS Maximum,
       Round(Avg([MathScore]),1) AS Average
FROM Students;
    </code></pre>

    <p>
      Example result:
    </p>

    <table style="width:60%; border-collapse:collapse; margin:0.6em 0 1.2em 0; font-size:0.95rem;">
      <thead>
        <tr style="background:#111;">
          <th style="padding:8px; text-align:left;">Statistic</th>
          <th style="padding:8px;">Math Score</th>
        </tr>
      </thead>
      <tbody>
        <tr><td style="padding:8px;">Minimum</td><td>70</td></tr>
        <tr><td style="padding:8px;">Maximum</td><td>92</td></tr>
        <tr><td style="padding:8px;">Average (Mean)</td><td>82.4</td></tr>
      </tbody>
    </table>

    <h4>2.5 Skewness & Shape Classification (VBA helper + query)</h4>

    <p>
      Access lacks a built-in skewness function. The assignment includes a VBA module that computes the sample skewness (Fisher-Pearson adjusted).
      Add this module in the VBA editor (Insert → Module):
    </p>

    <pre><code class="sql">
' --- Module: StatsHelpers ---
Public Function Skewness(FieldName As String, TableName As String) As Double
    ' Computes Fisher-Pearson sample skewness (adjusted)
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim n As Long
    Dim mean As Double
    Dim sum2 As Double
    Dim sum3 As Double
    Dim x As Double

    Set db = CurrentDb()
    Set rs = db.OpenRecordset("SELECT [" & FieldName & "] FROM [" & TableName & "] WHERE [" & FieldName & "] IS NOT NULL", dbOpenSnapshot)

    If rs.EOF Then
        Skewness = 0
        rs.Close
        Set rs = Nothing
        Set db = Nothing
        Exit Function
    End If

    ' first pass: count & mean
    n = 0
    mean = 0
    rs.MoveFirst
    Do While Not rs.EOF
        n = n + 1
        mean = mean + rs.Fields(0).Value
        rs.MoveNext
    Loop
    If n = 0 Then
        Skewness = 0
        rs.Close
        Set rs = Nothing
        Set db = Nothing
        Exit Function
    End If
    mean = mean / n

    ' second pass: central moments
    rs.MoveFirst
    sum2 = 0
    sum3 = 0
    Do While Not rs.EOF
        x = rs.Fields(0).Value - mean
        sum2 = sum2 + x ^ 2
        sum3 = sum3 + x ^ 3
        rs.MoveNext
    Loop

    rs.Close
    Set rs = Nothing
    Set db = Nothing

    If n < 3 Then
        Skewness = 0
        Exit Function
    End If

    Dim sd As Double
    sd = Sqr(sum2 / (n - 1)) ' sample std dev

    If sd = 0 Then
        Skewness = 0
    Else
        ' adjusted Fisher-Pearson coefficient (sample skewness)
        Skewness = (n / ((n - 1) * (n - 2))) * (sum3 / (sd ^ 3))
    End If
End Function
    </code></pre>

    <p>
      Use this function inside a query to map numeric skewness to a human-friendly shape summary:
    </p>

    <pre><code class="sql">
SELECT 'Math Score' AS Variable,
       Round(Avg([MathScore]),1) AS Mean,
       Round(StDev([MathScore]),1) AS StdDev,
       IIf(Skewness("MathScore","Students") > 0.5, "Right-skewed",
         IIf(Skewness("MathScore","Students") < -0.5, "Left-skewed", "Roughly symmetric")
       ) AS ShapeSummary
FROM Students
UNION ALL
SELECT 'Study Hours' AS Variable,
       Round(Avg([StudyHours]),1) AS Mean,
       Round(StDev([StudyHours]),1) AS StdDev,
       IIf(Skewness("StudyHours","Students") > 0.5, "Right-skewed",
         IIf(Skewness("StudyHours","Students") < -0.5, "Left-skewed", "Roughly symmetric")
       ) AS ShapeSummary
FROM Students
UNION ALL
SELECT 'Sleep Hours' AS Variable,
       Round(Avg([SleepHours]),1) AS Mean,
       Round(StDev([SleepHours]),1) AS StdDev,
       IIf(Skewness("SleepHours","Students") > 0.5, "Right-skewed",
         IIf(Skewness("SleepHours","Students") < -0.5, "Left-skewed", "Roughly symmetric")
       ) AS ShapeSummary
FROM Students;
    </code></pre>

    <p>
      The thresholds (±0.5) are suggested rules of thumb for this assignment to identify moderate skewness.
    </p>

    <h4>2.6 Visualizing results</h4>

    <p>
      After computing statistics, typical visualizations include histograms (univariate) and scatterplots (bivariate). In Access you can export query results to Excel or generate charts via Access forms/reports for better plotting.
    </p>

    <!-- -------------------------
         SECTION 3: Letter Distribution & Caesar Cipher
         (fully embedded from PDFs)
         ------------------------- -->
    <h3>3. Letter Distribution and the Caesar Cipher</h3>

    <p>
      Text can be treated as data: each letter is a univariate variable and its frequency distribution can be analyzed
      similarly to numeric variables. This section reproduces the assignment’s full analysis on the example phrase,
      including encryption, frequency counts, statistical decoding, and code.
    </p>

    <h4>3.1 Original phrase and encryption (Caesar)</h4>
    <p><strong>Original phrase:</strong></p>
    <blockquote><em>It was a relentless savage onslaught of drudgery and oblivion</em></blockquote>

    <p>
      Using a Caesar cipher with a shift of 3 (each letter moved 3 positions forward), the ciphertext becomes:
    </p>
    <blockquote><em>Lw zdv d uhohqwohvv vdydjh rqvodxjkw ri guxgjhub dqg reolylrq</em></blockquote>

    <p>
      The Caesar cipher maps letters with modular arithmetic (A→0 … Z→25):
    </p>
    <pre><code class="sql">
E(x) = (x + n) mod 26    ; encryption with shift n
D(x) = (x - n) mod 26    ; decryption with shift n
    </code></pre>

    <h4>3.2 Frequency distribution of the ciphertext</h4>

    <p>
      For frequency analysis we ignore non-letters and count occurrences of each letter. The assignment’s count (letters only, total = 52) is:
    </p>

    <table style="width:100%; border-collapse:collapse; margin:1em 0; font-size:0.95rem;">
      <thead>
        <tr style="background:#111;">
          <th style="padding:8px; text-align:left;">Letter</th>
          <th style="padding:8px; text-align:right;">Count</th>
          <th style="padding:8px; text-align:right;">%</th>
        </tr>
      </thead>
      <tbody>
        <tr><td style="padding:6px;">d</td><td style="text-align:right;">6</td><td style="text-align:right;">11.54%</td></tr>
        <tr><td style="padding:6px;">v</td><td style="text-align:right;">5</td><td style="text-align:right;">9.62%</td></tr>
        <tr><td style="padding:6px;">h</td><td style="text-align:right;">5</td><td style="text-align:right;">9.62%</td></tr>
        <tr><td style="padding:6px;">o</td><td style="text-align:right;">4</td><td style="text-align:right;">7.69%</td></tr>
        <tr><td style="padding:6px;">q</td><td style="text-align:right;">4</td><td style="text-align:right;">7.69%</td></tr>
        <tr><td style="padding:6px;">r</td><td style="text-align:right;">4</td><td style="text-align:right;">7.69%</td></tr>
        <tr><td style="padding:6px;">l</td><td style="text-align:right;">3</td><td style="text-align:right;">5.77%</td></tr>
        <tr><td style="padding:6px;">w</td><td style="text-align:right;">3</td><td style="text-align:right;">5.77%</td></tr>
        <tr><td style="padding:6px;">u</td><td style="text-align:right;">3</td><td style="text-align:right;">5.77%</td></tr>
        <tr><td style="padding:6px;">j</td><td style="text-align:right;">3</td><td style="text-align:right;">5.77%</td></tr>
        <tr><td style="padding:6px;">g</td><td style="text-align:right;">3</td><td style="text-align:right;">5.77%</td></tr>
        <tr><td style="padding:6px;">y</td><td style="text-align:right;">2</td><td style="text-align:right;">3.85%</td></tr>
        <tr><td style="padding:6px;">x</td><td style="text-align:right;">2</td><td style="text-align:right;">3.85%</td></tr>
        <tr><td style="padding:6px;">z</td><td style="text-align:right;">1</td><td style="text-align:right;">1.92%</td></tr>
        <tr><td style="padding:6px;">k</td><td style="text-align:right;">1</td><td style="text-align:right;">1.92%</td></tr>
        <tr><td style="padding:6px;">i</td><td style="text-align:right;">1</td><td style="text-align:right;">1.92%</td></tr>
        <tr><td style="padding:6px;">b</td><td style="text-align:right;">1</td><td style="text-align:right;">1.92%</td></tr>
        <tr><td style="padding:6px;">e</td><td style="text-align:right;">1</td><td style="text-align:right;">1.92%</td></tr>
      </tbody>
    </table>

    <h4>3.3 Methods to decode without the key</h4>

    <p>
      The PDFs present three decoding strategies:
    </p>
    <ol>
      <li><strong>Brute force</strong> — try all 25 shifts and read the correct plaintext.</li>
      <li><strong>Frequency alignment heuristic</strong> — map the most frequent ciphertext letter to <em>e</em> (or <em>t</em>, <em>a</em>) and try a few shifts.</li>
      <li><strong>Statistical scoring (chi-squared)</strong> — for each shift, decrypt and compute a chi-squared statistic between the candidate plaintext letter frequencies and expected English frequencies. The shift with the smallest chi-squared is the most likely.</li>
    </ol>

    <h4>3.4 Chi-squared approach (detailed)</h4>
    <p>
      The chi-squared statistic for a candidate decryption is:
    </p>
    <pre><code class="sql">
chi^2 = SUM_over_letters (Observed_letter_count - Expected_count)^2 / Expected_count
    </code></pre>
    <p>
      Expected counts are derived from standard English frequencies (e.g., E ≈ 12.7%, T ≈ 9.1%, ...), scaled by the number of letters.
      The assignment demonstrates that evaluating all 26 shifts and selecting the minimum chi-squared recovers the correct number (shift = 3) for the example.
    </p>

    <h4>3.5 Full Python implementation (as in the PDF)</h4>

    <p>
      The assignment provides an executable Python script that:
      <ol>
        <li>removes non-letters,</li>
        <li>tries all shifts,</li>
        <li>computes chi-squared for each candidate,</li>
        <li>selects the best shift and prints candidate decryptions.</li>
      </ol>
    </p>

    <pre><code class="python">
from collections import Counter
eng = {'a':8.167,'b':1.492,'c':2.782,'d':4.253,'e':12.702,'f':2.228,'g':2.015,'h':6.094,
       'i':6.966,'j':0.153,'k':0.772,'l':4.025,'m':2.406,'n':6.749,'o':7.507,'p':1.929,
       'q':0.095,'r':5.987,'s':6.327,'t':9.056,'u':2.758,'v':0.978,'w':2.360,'x':0.150,
       'y':1.974,'z':0.074}

def decrypt_caesar(s, k):
    out = []
    for ch in s:
        if ch.isalpha():
            base = 'a' if ch.islower() else 'A'
            out.append(chr((ord(ch) - ord(base) - k) % 26 + ord(base)))
        else:
            out.append(ch)
    return ''.join(out)

def chi_squared(s):
    letters = [c.lower() for c in s if c.isalpha()]
    N = len(letters)
    cnt = Counter(letters)
    chi = 0.0
    for ch, pct in eng.items():
        expected = pct/100.0 * N
        observed = cnt.get(ch, 0)
        chi += (observed - expected)**2 / expected if expected>0 else 0
    return chi

cipher = "Lw zdv d uhohqwohvv vdydjh rqvodxjkw ri guxgjhub dqg reolylrq"

scores = []
for k in range(26):
    dec = decrypt_caesar(cipher, k)
    scores.append((k, chi_squared(dec), dec))

best = min(scores, key=lambda t: t[1])
print("Best shift:", best[0])
print(best[2])
    </code></pre>

    <p>
      Running this script prints the best shift (3) and the decrypted sentence:
    </p>
    <blockquote>it was a relentless savage onslaught of drudgery and oblivion</blockquote>

    <h4>3.6 Practical considerations and notes</h4>
    <ul>
      <li>
        <strong>Short text limitations:</strong> Frequency methods are less reliable on very short texts (low N). In that case brute force combined with human inspection often works best.
      </li>
      <li>
        <strong>Language differences:</strong> The chi-squared approach requires expected frequencies for the language used. Using English frequencies on other languages reduces accuracy.
      </li>
      <li>
        <strong>Polyalphabetic ciphers:</strong> Frequency analysis needs adaptation for ciphers like Vigenère (key length estimation, index of coincidence, etc.). The assignment focuses on Caesar, which is monoalphabetic.
      </li>
    </ul>

    
    <hr>
    <section id="caesar-cipher">
      <h2>Caesar Cipher</h2>
      <p>Use this interactive tool to encrypt, decrypt, and analyze letter frequencies for the Caesar cipher.</p>
    
      <label for="cipherInput">Text to encrypt/decrypt</label>
      <textarea id="cipherInput" placeholder="Type or paste your text…"></textarea>
    
      <label for="shift">Shift (0–25):</label>
      <input type="number" id="shift" min="0" max="25" value="7">
    
      <!-- Encrypt / Decrypt area -->
      <button type="button" class="btn primary" onclick="caesarEncrypt()">Encrypt</button>
      <button type="button" class="btn" onclick="caesarDecrypt()">Decrypt</button>
      
      <!-- Keep result visible; allow user to copy it into input explicitly -->
      <button type="button" class="btn" onclick="useResultAsInput()">Use result as input</button>
    
      <label for="cipherOutput">Result</label>
      <textarea id="cipherOutput" readonly placeholder="The result will appear here…"></textarea>
    
      <div class="cipher-buttons">
        <!-- Brute / Auto decode -->
        <button type="button" class="btn secondary" onclick="bruteForce()">Brute force (show all 26)</button>
        <button type="button" class="btn secondary" onclick="autoDecode()">Auto-decode (by frequency)</button>
      </div>
    
      <p id="statusMsg" class="status"></p>
    
      <div id="freqChartContainer">
        <canvas id="freqChart"></canvas>
      </div>
    </section>

    
    <h3>Summary and final remarks</h3>

    <p>
      This homework links basic statistical reasoning with practical DBMS operations and a simple application of frequency analysis in cryptography.
      The univariate and bivariate analyses show how summary statistics (mean, std dev, min/max) allow inspection of data structure and anomalies,
      while the Caesar cipher example highlights how distributional properties (letter frequencies) support forensic decoding tasks.
    </p>

    <a href="index.html" class="back-button">← Back to Home</a>
  </article>
</main>

  <footer class="site-footer">
    © 2025 Alexandru Silivas — Student ID: 2252622 — silivas.2252622@studenti.uniroma1.it
  </footer>


  <!-- Chart.js library (for frequency histogram) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
<!-- Caesar Cipher script -->
<script src="caesar_cypher.js"></script>
  
</body>
</html>
