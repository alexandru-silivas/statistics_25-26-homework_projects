// pentest.js
// Simulate server weekly security as a random walk and compare empirical final-score distribution
// with theoretical Binomial-derived distribution. Uses Chart.js for visuals.

// Utility: binomial coefficient nCk (works for moderate n)
function nCk(n, k) {
  if (k < 0 || k > n) return 0;
  k = Math.min(k, n - k);
  let c = 1;
  for (let i = 1; i <= k; i++) {
    c = c * (n - (k - i)) / i;
  }
  return c;
}

// Get DOM values
function readParams() {
  const n = Math.max(1, parseInt(document.getElementById('inputN').value, 10));
  const m = Math.max(1, parseInt(document.getElementById('inputM').value, 10));
  let p = parseFloat(document.getElementById('inputP').value);
  if (Number.isNaN(p) || p < 0) p = 0;
  if (p > 1) p = 1;
  const sims = Math.max(1, parseInt(document.getElementById('inputSim').value, 10));
  return { n, m, p, sims };
}

// Derived weekly probabilities
function weeklyProbabilities(p, m) {
  const s = Math.pow(1 - p, m); // secure probability
  const b = 1 - s; // breach probability
  return { s, b };
}

// Mapping between K (secure weeks) and score S = 2K - n
function scoreFromK(k, n) {
  return 2 * k - n;
}
function kFromScore(s, n) {
  return (s + n) / 2;
}

// ---------------- Charts setup ----------------
const trajCtx = document.getElementById('trajChart').getContext('2d');
const histCtx = document.getElementById('histChart').getContext('2d');
const overlayCtx = document.getElementById('overlayChart').getContext('2d');

let trajChart = new Chart(trajCtx, {
  type: 'line',
  data: { labels: [], datasets: [{ label: 'Cumulative score', data: [], borderColor: 'rgba(78,163,255,0.95)', fill: false }] },
  options: { animation: { duration: 300 }, scales: { x: { title: { display: true, text: 'Week' } }, y: { title: { display: true, text: 'Score' } } } }
});

let histChart = new Chart(histCtx, {
  type: 'bar',
  data: { labels: [], datasets: [{ label: 'Empirical frequency', data: [], backgroundColor: 'rgba(78,163,255,0.75)' }] },
  options: { scales: { x: { title: { display: true, text: 'Final total score' } }, y: { title: { display: true, text: 'Count' } } } }
});

let overlayChart = new Chart(overlayCtx, {
  type: 'bar',
  data: { labels: [], datasets: [
    { label: 'Empirical count', data: [], backgroundColor: 'rgba(78,163,255,0.6)' },
    { label: 'Theoretical (binomial) expected count', data: [], type: 'line', borderColor: 'rgba(255,99,132,0.95)', tension:0.2, fill:false, pointRadius:4 }
  ]},
  options: { scales: { x: { title: { display: true, text: 'Final total score' } }, y: { title: { display: true, text: 'Count' } } } }
});

// ---------------- Simulation utilities ----------------

// simulateOneTrajectory: returns array of cumulative scores length n
function simulateOneTrajectory(n, s /* secure prob per week */) {
  const cumul = [];
  let current = 0;
  for (let i = 0; i < n; i++) {
    const secure = Math.random() < s;
    const step = secure ? 1 : -1;
    current += step;
    cumul.push(current);
  }
  return cumul;
}

// simulateMany: returns array of final scores (length sims)
function simulateManyTrajectories(n, s, sims) {
  const finals = new Array(sims);
  for (let t = 0; t < sims; t++) {
    let current = 0;
    for (let i = 0; i < n; i++) {
      const secure = Math.random() < s;
      current += secure ? 1 : -1;
    }
    finals[t] = current;
  }
  return finals;
}

// Build histogram counts keyed by score (from -n to n step 2)
function buildCounts(finals, n) {
  const counts = {};
  for (let k = -n; k <= n; k += 2) counts[k] = 0;
  for (const v of finals) {
    counts[v] = (counts[v] || 0) + 1;
  }
  // convert to arrays sorted by ascending score
  const labels = [];
  const data = [];
  for (let k = -n; k <= n; k += 2) {
    labels.push(k);
    data.push(counts[k] || 0);
  }
  return { labels, data, counts };
}

// Compute theoretical expected counts (scaled by sims) for each possible score
function theoreticalCounts(n, s, sims) {
  const b = 1 - s;
  const labels = [];
  const data = [];
  for (let k = 0; k <= n; k++) {
    // k = number of secure weeks
    const score = scoreFromK(k, n);
    const prob = nCk(n, k) * Math.pow(s, k) * Math.pow(b, n - k);
    labels.push(score);
    data.push(prob * sims);
  }
  // labels currently for k=0..n mapped to scores; need to reorder to ascending score
  // create map then order by score ascending -n to n step 2
  const map = {};
  for (let i = 0; i < labels.length; i++) map[labels[i]] = data[i];
  const outLabels = [], outData = [];
  for (let sc = -n; sc <= n; sc += 2) {
    outLabels.push(sc);
    outData.push(map[sc] || 0);
  }
  return { labels: outLabels, data: outData };
}

// ---------------- UI actions ----------------

function setStatus(msg) {
  const el = document.getElementById('hw7Status');
  el.textContent = 'Status: ' + msg;
}

// simulate a single trajectory and show live random-walk
function simulateOnce() {
  const { n, m, p } = readParams();
  const { s } = weeklyProbabilities(p, m);
  setStatus(`Simulating single trajectory (n=${n}, m=${m}, p=${p})...`);
  const cumul = simulateOneTrajectory(n, s);

  // update trajectory chart
  trajChart.data.labels = Array.from({ length: n }, (_, i) => i + 1);
  trajChart.data.datasets[0].data = cumul;
  trajChart.update();

  // Also precompute final single count display on hist chart (one sample)
  const final = cumul[cumul.length - 1];
  const { labels, data } = buildCounts([final], n);
  histChart.data.labels = labels;
  histChart.data.datasets[0].data = data;
  histChart.update();

  // prepare theoretical overlay but keep sims = 1 (so small)
  const th = theoreticalCounts(n, s, 1);
  overlayChart.data.labels = th.labels;
  overlayChart.data.datasets[0].data = data; // empirical (single)
  overlayChart.data.datasets[1].data = th.data; // theoretical scaled to sims=1
  overlayChart.update();

  setStatus(`Single trajectory done. Final score = ${final}.`);
}

// simulate many trajectories, update hist and overlay
function simulateMany() {
  const { n, m, p, sims } = readParams();
  const { s } = weeklyProbabilities(p, m);
  setStatus(`Running ${sims} simulations (n=${n}, m=${m}, p=${p}) â€” please wait...`);

  // Run in chunks to allow UI updates for very large sims
  const finals = simulateManyTrajectories(n, s, sims);

  // Build empirical histogram
  const { labels, data } = buildCounts(finals, n);
  histChart.data.labels = labels;
  histChart.data.datasets[0].data = data;
  histChart.update();

  // Theoretical (scaled to sims)
  const th = theoreticalCounts(n, s, sims);
  overlayChart.data.labels = th.labels;
  overlayChart.data.datasets[0].data = data;
  overlayChart.data.datasets[1].data = th.data;
  overlayChart.update();

  // Optionally show a sample random walk (first trajectory)
  const sampleCumul = simulateOneTrajectory(n, s);
  trajChart.data.labels = Array.from({ length: n }, (_, i) => i + 1);
  trajChart.data.datasets[0].data = sampleCumul;
  trajChart.update();

  setStatus(`Completed ${sims} simulations. Empirical histogram updated; overlay shows theoretical expected counts.`);
}

// Reset charts and UI
function resetAll() {
  trajChart.data.labels = [];
  trajChart.data.datasets[0].data = [];
  trajChart.update();

  histChart.data.labels = [];
  histChart.data.datasets[0].data = [];
  histChart.update();

  overlayChart.data.labels = [];
  overlayChart.data.datasets[0].data = [];
  overlayChart.data.datasets[1].data = [];
  overlayChart.update();

  setStatus('idle.');
}

// init
resetAll();
setStatus('idle.');

// expose for debugging in console if needed
window.simulateOnce = simulateOnce;
window.simulateMany = simulateMany;
window.resetAll = resetAll;
