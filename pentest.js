// pentest.js â€” Full implementation for Homework 7 (Option C, fixed axes & bins)

// Helper: binomial coefficient (works for n up to ~60 safely)
function nCk(n, k) {
  if (k < 0 || k > n) return 0;
  k = Math.min(k, n - k);
  let c = 1;
  for (let i = 1; i <= k; i++) {
    c = c * (n - (k - i)) / i;
  }
  return c;
}

// Convert number of secure weeks k -> total score S = 2k - n
function scoreFromK(k, n) { return 2 * k - n; }

// Generate weekly secure probability s given p and m
function weeklySecureProb(p, m) {
  return Math.pow(1 - p, m);
}

// Simulate one trajectory (returns array of cumulative scores length weeks)
function simulateTrajectory(weeks, m, p) {
  const s = weeklySecureProb(p, m);
  let score = 0;
  const path = [];
  for (let i = 0; i < weeks; i++) {
    const secure = Math.random() < s;
    score += secure ? 1 : -1;
    path.push(score);
  }
  return path;
}

// Simulate many trajectories and return array of final scores
function simulateFinals(weeks, m, p, sims) {
  const s = weeklySecureProb(p, m);
  const finals = new Array(sims);
  for (let t = 0; t < sims; t++) {
    let score = 0;
    for (let i = 0; i < weeks; i++) {
      const secure = Math.random() < s;
      score += secure ? 1 : -1;
    }
    finals[t] = score;
  }
  return finals;
}

// Build fixed bins from -weeks..weeks step 2 and counts
function buildFixedBins(finals, weeks) {
  const bins = [];
  const counts = {};
  for (let sc = -weeks; sc <= weeks; sc += 2) {
    bins.push(sc);
    counts[sc] = 0;
  }
  for (const v of finals) {
    if (counts.hasOwnProperty(v)) counts[v]++;
  }
  const data = bins.map(s => counts[s] || 0);
  return { bins, data, counts };
}

// Theoretical expected counts (scaled by sims) using Binomial(n, s)
function theoreticalCounts(weeks, m, p, sims) {
  const s = weeklySecureProb(p, m);
  const b = 1 - s;
  const map = {};
  for (let k = 0; k <= weeks; k++) {
    const score = scoreFromK(k, weeks);
    const prob = nCk(weeks, k) * Math.pow(s, k) * Math.pow(b, weeks - k);
    map[score] = prob * sims;
  }
  // produce array in fixed order
  const labels = [];
  const data = [];
  for (let sc = -weeks; sc <= weeks; sc += 2) {
    labels.push(sc);
    data.push(map[sc] || 0);
  }
  return { labels, data };
}

// --- Chart helpers with fixed axes ---
function lineChart(ctx, labels, datasets, options = {}) {
  return new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: Object.assign({
      animation: { duration: 400 },
      scales: {
        x: { title: { display: true, text: 'Week' }, min: 1, max: 50, ticks: { color: '#cfd9e6' } },
        y: { title: { display: true, text: 'Score' }, min: -50, max: 50, ticks: { color: '#cfd9e6' } }
      },
      plugins: { legend: { display: false } }
    }, options)
  });
}

function barChart(ctx, labels, data, options = {}) {
  return new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets: [{ label: 'Count', data, backgroundColor: 'rgba(78,163,255,0.85)' }] },
    options: Object.assign({
      scales: {
        x: { title: { display: true, text: 'Final score' }, ticks: { color: '#cfd9e6' } },
        y: { title: { display: true, text: 'Count' }, ticks: { color: '#cfd9e6' } }
      },
      plugins: { legend: { display: false } }
    }, options)
  });
}

// ---------------- Main fixed scenarios ----------------
function runDemo() {
  const weeks = 50;
  const p = 0.05;

  // Scenario settings (your choices: slightly lower than reference)
  const simsA = 80;   // 1 attacker
  const simsB = 80;   // 50 attackers
  const simsC = 400;  // many trials (cloud)

  // ---------- Panel A (1 attacker) ----------
  const mA = 1;
  const finalsA = simulateFinals(weeks, mA, p, simsA);
  const binsA = buildFixedBins(finalsA, weeks);
  const thA = theoreticalCounts(weeks, mA, p, simsA);

  // trajectory panel: draw a few sampled trajectories (up to 40)
  const sampleTrajA = [];
  const trajCountA = Math.min(40, simsA);
  for (let i = 0; i < trajCountA; i++) sampleTrajA.push(simulateTrajectory(weeks, mA, p));

  // plot A
  const labelsWeeks = Array.from({length: weeks}, (_, i) => i + 1);
  const datasetsTrajA = sampleTrajA.map((d, idx) => ({
    data: d,
    borderColor: `rgba(78,163,255,${0.9 - idx * 0.015})`,
    borderWidth: 1.5,
    fill: false,
    tension: 0.2
  }));
  lineChart(document.getElementById('trajA').getContext('2d'), labelsWeeks, datasetsTrajA);

  barChart(document.getElementById('histA').getContext('2d'),
           binsA.bins.map(String), binsA.data);

  // overlay histogram + theoretical line
  const overlayA = barChart(document.getElementById('overlayA').getContext('2d'),
                            binsA.bins.map(String), binsA.data, { animation: { duration: 200 }});
  // add theoretical as line dataset
  overlayA.data.datasets.push({
    label: 'Theoretical (expected count)',
    data: thA.data,
    type: 'line',
    borderColor: 'rgba(255,99,132,0.95)',
    borderWidth: 2,
    fill: false,
    tension: 0.15,
    pointRadius: 3
  });
  overlayA.update();

  // ---------- Panel B (50 attackers) ----------
  const mB = 50;
  const finalsB = simulateFinals(weeks, mB, p, simsB);
  const binsB = buildFixedBins(finalsB, weeks);
  const thB = theoreticalCounts(weeks, mB, p, simsB);

  // sample trajectories (fewer colored lines, same logic)
  const sampleTrajB = [];
  const trajCountB = Math.min(40, simsB);
  for (let i = 0; i < trajCountB; i++) sampleTrajB.push(simulateTrajectory(weeks, mB, p));
  const datasetsTrajB = sampleTrajB.map((d, idx) => ({
    data: d,
    borderColor: `rgba(255,140,20,${0.85 - idx * 0.012})`,
    borderWidth: 1.2,
    fill: false,
    tension: 0.2
  }));
  lineChart(document.getElementById('trajB').getContext('2d'), labelsWeeks, datasetsTrajB);

  barChart(document.getElementById('histB').getContext('2d'),
           binsB.bins.map(String), binsB.data);

  const overlayB = barChart(document.getElementById('overlayB').getContext('2d'),
                            binsB.bins.map(String), binsB.data);
  overlayB.data.datasets.push({
    label: 'Theoretical (expected count)',
    data: thB.data,
    type: 'line',
    borderColor: 'rgba(255,99,132,0.95)',
    borderWidth: 2,
    fill: false,
    tension: 0.15,
    pointRadius: 3
  });
  overlayB.update();

  // ---------- Panel C (cloud of many trajectories + histogram) ----------
  const mC = 50;
  const finalsC = simulateFinals(weeks, mC, p, simsC);
  const binsC = buildFixedBins(finalsC, weeks);
  const thC = theoreticalCounts(weeks, mC, p, simsC);

  // cloud of trajectories (all sims plotted faintly) - limit per performance: cap at 400
  const maxTraj = Math.min(simsC, 400);
  const datasetsC = [];
  for (let i = 0; i < maxTraj; i++) {
    const t = simulateTrajectory(weeks, mC, p);
    datasetsC.push({
      data: t,
      borderColor: 'rgba(160,160,160,0.18)',
      borderWidth: 1,
      fill: false,
      tension: 0.2
    });
  }
  new Chart(document.getElementById('trajC').getContext('2d'), {
    type: 'line',
    data: { labels: labelsWeeks, datasets: datasetsC },
    options: {
      animation: { duration: 0 },
      scales: {
        x: { title: { display: true, text: 'Week' }, min: 1, max: 50 },
        y: { title: { display: true, text: 'Score' }, min: -50, max: 50 }
      },
      plugins: { legend: { display: false } }
    }
  });

  const histC = barChart(document.getElementById('histC').getContext('2d'),
                         binsC.bins.map(String), binsC.data);
  histC.data.datasets.push({
    label: 'Theoretical (expected count)',
    data: thC.data,
    type: 'line',
    borderColor: 'rgba(255,99,132,0.95)',
    borderWidth: 2,
    fill: false,
    tension: 0.15,
    pointRadius: 3
  });
  histC.update();
}

// Run on load
window.addEventListener('load', runDemo);
