// pentest.js — updated: isolated panels, scaled theoretical overlay, axis labels, interactive reset
// Uses Chart.js

// ---------- utility functions ----------
function nCk(n, k) {
  if (k < 0 || k > n) return 0;
  k = Math.min(k, n - k);
  let c = 1;
  for (let i = 1; i <= k; i++) c = c * (n - (k - i)) / i;
  return Math.round(c);
}

function weeklySecureProb(p, m) {
  return Math.pow(1 - p, m);
}
function scoreFromK(k, n) {
  return 2 * k - n;
}

// fixed bins: -weeks, -weeks+2, ..., weeks
function fixedBins(weeks) {
  const bins = [];
  for (let sc = -weeks; sc <= weeks; sc += 2) bins.push(sc);
  return bins;
}

// simulate one walk returning full path
function simulateWalk(weeks, m, p, forceBalanced = false) {
  const s = forceBalanced ? 0.5 : weeklySecureProb(p, m);
  let score = 0;
  const path = [];
  for (let i = 0; i < weeks; i++) {
    const secure = Math.random() < s;
    score += secure ? 1 : -1;
    path.push(score);
  }
  return path;
}

// simulate many walks: return list of final scores and trajectories
function simulateMany(weeks, m, p, sims, forceBalanced = false) {
  const finals = [];
  const trajs = [];
  for (let i = 0; i < sims; i++) {
    const t = simulateWalk(weeks, m, p, forceBalanced);
    trajs.push(t);
    finals.push(t[t.length - 1]);
  }
  return { finals, trajs };
}

// build counts array aligned to fixed bins
function buildCounts(finals, weeks) {
  const bins = fixedBins(weeks);
  const map = {};
  bins.forEach(b => map[b] = 0);
  finals.forEach(v => { if (map.hasOwnProperty(v)) map[v]++; });
  const counts = bins.map(b => map[b]);
  return { bins, counts };
}

// theoretical expected counts (counts = probs * sims), ordered in fixed bins
function theoreticalCounts(weeks, m, p, sims, forceBalanced = false) {
  const s = forceBalanced ? 0.5 : weeklySecureProb(p, m);
  const map = {};
  for (let k = 0; k <= weeks; k++) {
    const sc = scoreFromK(k, weeks);
    const prob = nCk(weeks, k) * Math.pow(s, k) * Math.pow(1 - s, weeks - k);
    map[sc] = (map[sc] || 0) + prob;
  }
  const bins = fixedBins(weeks);
  const expected = bins.map(b => (map[b] || 0) * sims);
  return { bins, expected, probs: bins.map(b => (map[b] || 0)) };
}

// ---------- Chart helpers (destroy previous chart if exists) ----------
let charts = {}; // hold chart instances to destroy when redrawing

function destroyChart(id) {
  if (charts[id]) {
    try { charts[id].destroy(); } catch (e) { /* ignore */ }
    delete charts[id];
  }
}

function drawTrajectories(canvasId, trajs, weeks) {
  destroyChart(canvasId);
  if (!trajs || trajs.length === 0) return;
  const ctx = document.getElementById(canvasId).getContext('2d');
  const labels = Array.from({length: weeks}, (_, i) => i + 1);
  const datasets = trajs.map((t, idx) => ({
    label: `run ${idx+1}`,
    data: t,
    borderColor: 'rgba(78,163,255,0.35)',
    borderWidth: 1,
    fill: false,
    tension: 0.2,
    pointRadius: 0
  }));
  charts[canvasId] = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      animation: false,
      scales: {
        x: { title: { display: true, text: 'Weeks', color: '#cfd9e6' }, ticks: { color: '#cfd9e6' } },
        y: { title: { display: true, text: 'Cumulative score', color: '#cfd9e6' }, min:-50, max:50, ticks: { color: '#cfd9e6' } }
      },
      plugins: { legend: { display: false } }
    }
  });
}

function drawHistogram(canvasId, weeks, countsObj, theoryObj, sims) {
  // countsObj: { bins, counts } ; theoryObj: { bins, expected }
  destroyChart(canvasId);
  const ctx = document.getElementById(canvasId).getContext('2d');

  // labels are bins (numbers)
  const labels = countsObj.bins.map(String);
  const countData = countsObj.counts;
  const theoryData = theoryObj.expected; // already scaled by sims inside theoreticalCounts

  charts[canvasId] = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'Empirical counts',
          data: countData,
          backgroundColor: 'rgba(78,163,255,0.85)',
          yAxisID: 'y'
        },
        {
          type: 'line',
          label: 'Theoretical (expected count)',
          data: theoryData,
          borderColor: 'rgba(255,80,120,0.95)',
          borderWidth: 2,
          fill: false,
          pointRadius: 3,
          yAxisID: 'y'
        }
      ]
    },
    options: {
      animation: false,
      scales: {
        x: {
          title: { display: true, text: 'Final score (S = 2K − n)', color: '#cfd9e6' },
          ticks: { color: '#cfd9e6' }
        },
        y: {
          title: { display: true, text: 'Number of trajectories (counts)', color: '#cfd9e6' },
          ticks: { color: '#cfd9e6' },
          beginAtZero: true
        }
      },
      plugins: {
        legend: { labels: { color: '#e6eef8' } }
      }
    }
  });
}

// ---------- PANEL A (isolated) ----------
(function panelA() {
  const weeks = 50;
  const m = 1;
  const p = 0.05;
  const sims = 80;

  const { finals, trajs } = simulateMany(weeks, m, p, sims, false);
  const countsObj = buildCounts(finals, weeks);
  const theoryObj = theoreticalCounts(weeks, m, p, sims, false);

  // draw (limit plotted trajectories to 40 for readability)
  drawTrajectories('trajA', trajs.slice(0, Math.min(trajs.length, 40)), weeks);
  drawHistogram('histA', weeks, countsObj, theoryObj, sims);
})();

// ---------- PANEL B (isolated, forced balanced s=0.5) ----------
(function panelB() {
  const weeks = 50;
  const m = 50;      // label only; we force s=0.5
  const p = 0.05;    // ignored for forceBalanced=true
  const sims = 80;
  const forceBalanced = true;

  const { finals, trajs } = simulateMany(weeks, m, p, sims, forceBalanced);
  const countsObj = buildCounts(finals, weeks);
  const theoryObj = theoreticalCounts(weeks, m, p, sims, forceBalanced);

  drawTrajectories('trajB', trajs.slice(0, Math.min(trajs.length, 40)), weeks);
  drawHistogram('histB', weeks, countsObj, theoryObj, sims);
})();

// ---------- PANEL C (isolated) ----------
(function panelC() {
  const weeks = 50;
  const m = 50;
  const p = 0.05;
  const sims = 400;

  const { finals, trajs } = simulateMany(weeks, m, p, sims, false);
  const countsObj = buildCounts(finals, weeks);
  const theoryObj = theoreticalCounts(weeks, m, p, sims, false);

  drawTrajectories('trajC', trajs.slice(0, Math.min(trajs.length, 50)), weeks);
  drawHistogram('histC', weeks, countsObj, theoryObj, sims);
})();

// ---------- INTERACTIVE (Run + Reset) ----------
function clearInteractiveCanvases() {
  destroyChart('trajI');
  destroyChart('histI');
  const tctx = document.getElementById('trajI').getContext('2d');
  tctx.clearRect(0, 0, tctx.canvas.width, tctx.canvas.height);
  const hctx = document.getElementById('histI').getContext('2d');
  hctx.clearRect(0, 0, hctx.canvas.width, hctx.canvas.height);
}

function runInteractive() {
  const weeks = Math.max(1, parseInt(document.getElementById('i_weeks').value, 10) || 50);
  const m = Math.max(1, parseInt(document.getElementById('i_m').value, 10) || 10);
  let p = parseFloat(document.getElementById('i_p').value);
  if (isNaN(p) || p < 0) p = 0;
  if (p > 1) p = 1;
  const sims = Math.max(1, parseInt(document.getElementById('i_sims').value, 10) || 200);

  // do simulations
  const { finals, trajs } = simulateMany(weeks, m, p, sims, false);
  const countsObj = buildCounts(finals, weeks);
  const theoryObj = theoreticalCounts(weeks, m, p, sims, false);

  // draw (limit trajs plotted for readability)
  drawTrajectories('trajI', trajs.slice(0, Math.min(trajs.length, 200)), weeks);
  drawHistogram('histI', weeks, countsObj, theoryObj, sims);
}

function resetInteractive() {
  // reset inputs to sensible defaults
  document.getElementById('i_weeks').value = 50;
  document.getElementById('i_m').value = 10;
  document.getElementById('i_p').value = 0.05;
  document.getElementById('i_sims').value = 200;

  // clear and destroy charts
  clearInteractiveCanvases();
}
