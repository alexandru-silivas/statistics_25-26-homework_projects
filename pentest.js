// pentest.js â€” Homework 7 fully implemented (Option C + interactive)

// ---------- helpers ----------
function nCk(n, k) {
  if (k < 0 || k > n) return 0;
  k = Math.min(k, n - k);
  let c = 1;
  for (let i = 1; i <= k; i++) c = c * (n - (k - i)) / i;
  return c;
}
function scoreFromK(k, n) { return 2 * k - n; }
function weeklySecureProb(p, m) { return Math.pow(1 - p, m); }

// simulate trajectory of cumulative scores length weeks
function simulateTrajectory(weeks, m, p) {
  const s = weeklySecureProb(p, m);
  let score = 0;
  const path = [];
  for (let i = 0; i < weeks; i++) {
    const secure = Math.random() < s;
    score += secure ? 1 : -1;
    path.push(score);
  }
  return path;
}

// simulate finals array
function simulateFinals(weeks, m, p, sims) {
  const s = weeklySecureProb(p, m);
  const finals = new Array(sims);
  for (let t = 0; t < sims; t++) {
    let score = 0;
    for (let i = 0; i < weeks; i++) {
      score += (Math.random() < s) ? 1 : -1;
    }
    finals[t] = score;
  }
  return finals;
}

// fixed bins from -weeks..weeks step 2
function fixedBins(weeks) {
  const bins = [];
  for (let sc = -weeks; sc <= weeks; sc += 2) bins.push(sc);
  return bins;
}
function buildCounts(finals, weeks) {
  const map = {};
  for (const sc of fixedBins(weeks)) map[sc] = 0;
  for (const v of finals) if (map.hasOwnProperty(v)) map[v]++;
  const labels = Object.keys(map).map(s => parseInt(s, 10));
  const data = labels.map(l => map[l]);
  return { labels, data, map };
}

function theoreticalCounts(weeks, m, p, sims) {
  const s = weeklySecureProb(p, m);
  const map = {};
  for (let k = 0; k <= weeks; k++) {
    const score = scoreFromK(k, weeks);
    const prob = nCk(weeks, k) * Math.pow(s, k) * Math.pow(1 - s, weeks - k);
    map[score] = prob * sims;
  }
  const labels = [];
  const data = [];
  for (let sc = -weeks; sc <= weeks; sc += 2) {
    labels.push(sc);
    data.push(map[sc] || 0);
  }
  return { labels, data };
}

// ---------- Chart helpers ----------
function createLineChart(ctx, labels, datasets, options = {}) {
  return new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: Object.assign({
      animation: { duration: 400 },
      scales: {
        x: { title: { display: true, text: 'Week' }, min: 1, max: 50, ticks: { color: '#cfd9e6' } },
        y: { title: { display: true, text: 'Score' }, min: -50, max: 50, ticks: { color: '#cfd9e6' } }
      },
      plugins: { legend: { display: false } }
    }, options)
  });
}
function createBarChart(ctx, labels, data, options = {}) {
  return new Chart(ctx, {
    type: 'bar',
    data: { labels: labels.map(String), datasets: [{ label: 'Count', data, backgroundColor: 'rgba(78,163,255,0.85)' }] },
    options: Object.assign({
      scales: {
        x: { title: { display: true, text: 'Final score' }, ticks: { color: '#cfd9e6' } },
        y: { title: { display: true, text: 'Count' }, ticks: { color: '#cfd9e6' } }
      },
      plugins: { legend: { display: false } }
    }, options)
  });
}

// ---------- Fixed demo panels ----------
function runFixedPanels() {
  const weeks = 50;
  const labelsWeeks = Array.from({length: weeks}, (_, i) => i + 1);
  const simsA = 80, simsB = 80, simsC = 400;
  const p = 0.05;

  // Panel A: realistic (m=1, p=0.05)
  const mA = 1;
  const finalsA = simulateFinals(weeks, mA, p, simsA);
  const countsA = buildCounts(finalsA, weeks);
  const thA = theoreticalCounts(weeks, mA, p, simsA);

  // sample trajectories for A (up to 40)
  const trajsA = [];
  const capA = Math.min(40, simsA);
  for (let i = 0; i < capA; i++) trajsA.push(simulateTrajectory(weeks, mA, p));
  const datasetsA = trajsA.map((d, idx) => ({
    data: d,
    borderColor: `rgba(78,163,255,${0.9 - idx * 0.015})`,
    borderWidth: 1.3, fill: false, tension: 0.2
  }));
  createLineChart(document.getElementById('trajA').getContext('2d'), labelsWeeks, datasetsA);
  createBarChart(document.getElementById('histA').getContext('2d'), countsA.labels, countsA.data);
  const overlayA = createBarChart(document.getElementById('overlayA').getContext('2d'), countsA.labels, countsA.data);
  overlayA.data.datasets.push({
    label: 'Theoretical (expected count)',
    data: thA.data,
    type: 'line',
    borderColor: 'rgba(255,99,132,0.95)',
    borderWidth: 2, fill: false, tension: 0.15, pointRadius: 3
  });
  overlayA.update();

  // Panel B: balanced random walk (force s=0.5)
  // We'll emulate this by setting s=0.5 in theoretical and in simulations we sample with prob 0.5
  const mB = 50; // keep label but we will override s
  const sB = 0.5;
  function simulateTrajectoryBalanced(weeks, s) {
    let score = 0; const path = [];
    for (let i = 0; i < weeks; i++) { score += (Math.random() < s) ? 1 : -1; path.push(score); }
    return path;
  }
  function simulateFinalsBalanced(weeks, s, sims) {
    const finals = new Array(sims);
    for (let t = 0; t < sims; t++) {
      let score = 0;
      for (let i = 0; i < weeks; i++) score += (Math.random() < s) ? 1 : -1;
      finals[t] = score;
    }
    return finals;
  }
  const finalsB = simulateFinalsBalanced(weeks, sB, simsB);
  const countsB = buildCounts(finalsB, weeks);
  // theoretical for s=0.5: use mapping k->score using sB
  const thB_map = {};
  for (let k = 0; k <= weeks; k++) {
    const sc = scoreFromK(k, weeks);
    const prob = nCk(weeks, k) * Math.pow(sB, k) * Math.pow(1 - sB, weeks - k);
    thB_map[sc] = prob * simsB;
  }
  const thBlabels = [], thBdata = [];
  for (let sc = -weeks; sc <= weeks; sc += 2) { thBlabels.push(sc); thBdata.push(thB_map[sc] || 0); }

  const trajsB = [];
  const capB = Math.min(40, simsB);
  for (let i = 0; i < capB; i++) trajsB.push(simulateTrajectoryBalanced(weeks, sB));
  const datasetsB = trajsB.map((d, idx) => ({
    data: d,
    borderColor: `rgba(110,200,160,${0.9 - idx * 0.015})`,
    borderWidth: 1.2, fill: false, tension: 0.2
  }));
  createLineChart(document.getElementById('trajB').getContext('2d'), labelsWeeks, datasetsB);
  createBarChart(document.getElementById('histB').getContext('2d'), countsB.labels, countsB.data);
  const overlayB = createBarChart(document.getElementById('overlayB').getContext('2d'), countsB.labels, countsB.data);
  overlayB.data.datasets.push({
    label: 'Theoretical (expected count)',
    data: thBdata,
    type: 'line',
    borderColor: 'rgba(255,99,132,0.95)',
    borderWidth: 2, fill: false, tension: 0.15, pointRadius: 3
  });
  overlayB.update();

  // Panel C: strong attack (m=50, p=0.05, many sims)
  const mC = 50;
  const finalsC = simulateFinals(weeks, mC, p, simsC);
  const countsC = buildCounts(finalsC, weeks);
  const thC = theoreticalCounts(weeks, mC, p, simsC);

  // cloud of trajectories (cap for performance)
  const maxTraj = Math.min(simsC, 400);
  const datasetsC = [];
  for (let i = 0; i < maxTraj; i++) {
    const t = simulateTrajectory(weeks, mC, p);
    datasetsC.push({ data: t, borderColor: 'rgba(160,160,160,0.18)', borderWidth: 1, fill: false, tension: 0.2 });
  }
  createLineChart(document.getElementById('trajC').getContext('2d'), labelsWeeks, datasetsC, { animation:{duration:0} });
  const histChartC = createBarChart(document.getElementById('histC').getContext('2d'), countsC.labels, countsC.data);
  histChartC.data.datasets.push({
    label: 'Theoretical (expected count)',
    data: thC.data,
    type: 'line',
    borderColor: 'rgba(255,99,132,0.95)',
    borderWidth: 2, fill: false, tension: 0.15, pointRadius: 3
  });
  histChartC.update();
}

// ---------- Interactive panel ----------
let interactiveTrajChart = null;
let interactiveHistChart = null;

function clearInteractive() {
  if (interactiveTrajChart) { interactiveTrajChart.destroy(); interactiveTrajChart = null; }
  if (interactiveHistChart) { interactiveHistChart.destroy(); interactiveHistChart = null; }
}

function runInteractive() {
  const n = Math.max(1, parseInt(document.getElementById('intN').value, 10));
  const m = Math.max(1, parseInt(document.getElementById('intM').value, 10));
  let p = parseFloat(document.getElementById('intP').value);
  if (isNaN(p) || p < 0) p = 0; if (p > 1) p = 1;
  const sims = Math.max(1, parseInt(document.getElementById('intS').value, 10));

  // simulate trajectories (limit plotted lines for readability)
  const capPlot = Math.min(200, sims);
  const trajs = [];
  for (let i = 0; i < capPlot; i++) trajs.push(simulateTrajectory(n, m, p));
  const labelsWeeks = Array.from({length: n}, (_, i) => i + 1);
  const datasets = trajs.map((d, idx) => ({ data: d, borderColor: `rgba(100,120,200,${0.9 - idx * 0.002})`, borderWidth: 1, fill:false, tension:0.2 }));

  clearInteractive();
  interactiveTrajChart = new Chart(document.getElementById('trajI').getContext('2d'), {
    type: 'line',
    data: { labels: labelsWeeks, datasets },
    options: { animation:{duration:200}, scales:{ x:{min:1,max:n}, y:{min:-50,max:50} }, plugins:{legend:{display:false}} }
  });

  // histogram
  const finals = simulateFinals(n, m, p, sims);
  const binsObj = buildCounts(finals, n);
  const th = theoreticalCounts(n, m, p, sims);

  interactiveHistChart = createBarChart(document.getElementById('histI').getContext('2d'), binsObj.labels, binsObj.data);
  interactiveHistChart.data.datasets.push({
    label: 'Theoretical (expected count)',
    data: th.data,
    type: 'line',
    borderColor: 'rgba(255,99,132,0.95)',
    borderWidth: 2, fill: false, tension: 0.15, pointRadius: 3
  });
  interactiveHistChart.update();
}

function resetInteractive() {
  document.getElementById('intN').value = 50;
  document.getElementById('intM').value = 10;
  document.getElementById('intP').value = 0.05;
  document.getElementById('intS').value = 200;
  clearInteractive();
  // clear canvases
  document.getElementById('trajI').getContext('2d').clearRect(0,0,800,400);
  document.getElementById('histI').getContext('2d').clearRect(0,0,800,400);
}

// run demos on load
window.addEventListener('load', runFixedPanels);
